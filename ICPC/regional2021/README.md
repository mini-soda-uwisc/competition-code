# Notes

## A

我们可以通过维护 **异或前缀和** 来处理区间的奇数偶数查询。

详细描述如下：

由于字符串只包含字母 `a` 到 `f`，我们可以使用状态压缩来优化查询。通过二进制表示每个字符出现次数的奇偶性，总共可以有 $2^6$ 种不同的状态。

如果一个子串满足其中的每个字符出现次数为偶数次，那么从开始 $m_{l-1}$ 到 $m_r$ 满足以下条件：（`m`为从`0`到`n`，每个下表对应状态的异或前缀和）

其中 ![公式](https://latex.codecogs.com/svg.latex?m_r%20-%20m_{l-1}%20=%200) 表示满足要求的子串，可以看出状态需要相等。

我们可以使用 **线段树** 来维护一个长度为 `64` 的数组，表示这个前缀和可表示的状态。

对于每一种状态，其贡献可以表示为：

![公式](https://latex.codecogs.com/svg.latex?\frac{state_i%20*%20(state_i%20-%201)}{2})

在进行区间修改时，我们需要用懒标记来传递修改，覆盖从 $x + 1$ 到结尾的区间。线段树的下标 $i$ 对应着节点 $i + 1$，考虑到异或前缀和的定义，考虑左边界为`0`，因此下标 `0` 需要被包含在内。

## B

考虑到这是节点 `u` 和 `v` 的路径都是唯一确定的，也就是链。

朴素的暴力做法是找到这条链，然后从 `a` 开始计算

$$
\text{sum} \times 10 \mod m + s_i
$$

直到 `b`。这样是会超时的。

通过链的关系，我们可以把这个操作使用倍增处理。但同时考虑两个点可能不在一条链上，那么还要使用 `LCA`（最近公共祖先）来维护。

详细地，对于两个点不在一条链上，可以预处理一个下降数组和上升数组。下降数组维护的是从根节点到每个节点合成数字取模 `m` 的值。相同的，上升数组是从叶子节点到根节点合成数字取模 `m` 的值，本题代码使用的是倍增算法来查询叶子节点到高位节点的合成数。

倍增公式为：

$
\text{f}[u][i + 1] = \left( \text{f}[u][i] \times (10^{2^{i}}) + \text{f}[v][i] \right) \mod m
$

$
\text{up}[u][0] = \text{节点的数字}
$

最后查询两个节点的最近公共祖先，并分别讨论求下降路径合成数，倍增查询（参考以上初始化公式）求上升路径合成数。然后合并即可。


## D

把数字转换为二进制，"." = 0，"*" = 1 竖过来输出即可，注意每一列中间还要空一格。

## G

G为分类讨论，Bob的数字必须满足唯一性。

考虑所有情况，并讨论Bob的数字能不能被唯一代表。

如 `BAAB`，Alice的数字必须为`2`，`8`，才能满足Bob可确定的数字: `1`, `9`。

## H

H为BFS模拟。以分层图的方向想，在一次循环内需要达成两次操作：

第一次是遍历车可到的点。用`v`记录走过。如果格子是在攻击范围内但可以到达，则`mp`标记。如果能吃马，就将被吃的马的下标放入`队列2`。

第二次操作为从`队列2`中枚举所有被吃了的马，然后重置被攻击的格子。如果有格子是完全安全的且被第一次操作`mp`标记了，那么这个格子就是可达的，加入`队列1`并用`v`记录。

在每一次操作中判断有没有达到T。如果最后没有点可以走了（到达不了T）那就输出 no。

## E

如果不存在 0，则一定存在一种分法尽可能等分 2。

题目允许一个人的土地完全包围另一个人的。

`min(n, m) > 1`: 如果图上仅有 1 行（或列），则 1 的位置不能在中间，否则将把另一个人的土地分割成两部分。


## L

模拟题，暴力统计即可。
