# Notes

## A

我们可以通过维护 **异或前缀和** 来处理区间的奇数偶数查询。

详细描述如下：

由于字符串只包含字母 `a` 到 `f`，我们可以使用状态压缩来优化查询。通过二进制表示每个字符出现次数的奇偶性，总共可以有 $2^6$ 种不同的状态。

如果一个子串满足其中的每个字符出现次数为偶数次，那么从开始 $m_{l-1}$ 到 $m_r$ 满足以下条件：（`m`为从`0`到`n`，每个下表对应状态的异或前缀和）

其中 ![公式](https://latex.codecogs.com/svg.latex?m_r%20-%20m_{l-1}%20=%200) 表示满足要求的子串，可以看出状态需要相等。

我们可以使用 **线段树** 来维护一个长度为 `64` 的数组，表示这个前缀和可表示的状态。

对于每一种状态，其贡献可以表示为：

![公式](https://latex.codecogs.com/svg.latex?\frac{state_i%20*%20(state_i%20-%201)}{2})

在进行区间修改时，我们需要用懒标记来传递修改，覆盖从 $x + 1$ 到结尾的区间。线段树的下标 $i$ 对应着节点 $i + 1$，考虑到异或前缀和的定义，考虑左边界为`0`，因此下标 `0` 需要被包含在内。

## G

G为分类讨论，Bob的数字必须满足唯一性。

考虑所有情况，并讨论Bob的数字能不能被唯一代表。

如 `BAAB`，Alice的数字必须为`2`，`8`，才能满足Bob可确定的数字: `1`, `9`。

## H

H为BFS模拟。以分层图的方向想，在一次循环内需要达成两次操作：

第一次是遍历车可到的点。用`v`记录走过。如果格子是在攻击范围内但可以到达，则`mp`标记。如果能吃马，就将被吃的马的下标放入`队列2`。

第二次操作为从`队列2`中枚举所有被吃了的马，然后重置被攻击的格子。如果有格子是完全安全的且被第一次操作`mp`标记了，那么这个格子就是可达的，加入`队列1`并用`v`记录。

在每一次操作中判断有没有达到T并输出答案。

## E

如果不存在 0，则一定存在一种分法尽可能等分 2。

题目允许一个人的土地完全包围另一个人的。

`min(n, m) > 1`: 如果图上仅有 1 行（或列），则 1 的位置不能在中间，否则将把另一个人的土地分割成两部分。


## L

模拟题，暴力统计即可。
